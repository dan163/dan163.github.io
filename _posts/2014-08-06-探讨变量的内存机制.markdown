---
layout: post
title:  探讨变量的内存机制
date: 2014-08-06T17:06:36+08:00
comments: true
categories:
    - iOS
tags:
    - 内存
---

## 变量在内存是个什么东西？

变量（variable）可以说是我们日常代码最为熟悉的。比如，

```python
int a = 10;
int *b = &a;
int* a[4], int (*a)[4];
NSArray *intArr = [[NSArray alloc] init];
```

我们经常会说变量a，指针b，数组intArr，而实际上a、b和intArr都是变量（variable），那么变量究竟在内存中是什么个东西？

变量，实际上是个标识符（identifier），用来指代一个内存区域。变量a，指的就是一内存区域的值。

因此，编译器对上面的操作分别是：

1. 首先，根据我们定义的变量a的类型int，因为int类型是4个字节的，因此，编译器会在当前空余的内存中找到4个字节的地址，地址里面的值为10，然后把变量名a保存进符号表，并通过这个符号表的索引对应实际的内存地址。

2. 对应变量b，其类型是int*，系统不存在int*这种类型，那么编译器是如何确定分配的字节数并为它分配内存空间？

在1中，int类型是编译器认识的基本类型，因此它分配了4个字节的内存空间，这个内存空间上保存的就是int数值。
内存空间除了保存基本的数值类型外，还能保存空间地址。保存空间地址的变量我们称之为指针变量，因此指针变量实际上也是变量。
我们使用*来表示变量保存的是空间地址，任意类型后面+*都是表示指针类型，分配给指针类型的字节是8字节（64位）
我们经常听到“指针指向..”其实这种说法是不严谨的，应该说“指针变量指向..”，而这句话的意思，其实就是指针变量保存的内存空间的地址指向...，重点在于理解好，指针变量==指针变量的内存空间
在指针变量前面+*，表示取指针变量指向的东西。掌握指针变量，注意指针变量的类型和指针变量指向的类型。
因此，对于2的正确理解是：编译器通过语法知道int*指针类型，而指针类型是8个字节（64位），因此，编译器在当前空余空间内存找到8个字节的地址，然后把变量名b保存进字符表，并通过这个字符表的索引对应实际的内存地址。指针变量本质上是存储空间地址的变量。

3. []的优先级是大于*的，主要通过这个优先级来判断，int* a[4]表示的指针数组，数组a[4]里面存储的都是指针，而int (*a)[4]则是数组指针，表示指针变量a指针int类型的数组。

4. 4是OC常见的语法，根据上面知识，我们容易知道，指针变量intArr指向NSArray的对象。



在ObjC中，基本类型不能满足我们程序的需求，CocoaFramework给我们提供了其他很多类型，像NSString、NSArray、NSSet等，这些类型都是在heap上创建的对象，而通过alloc/new/copy等创建了对象等同于在heap上创建了一块内存区域，这时，我们需要一个指针变量指向这个对象，也就是说，指针变量保存对象的内存地址。

在以前的MRC中，我们经常可以看到：

```python
NSObject *obj0 = [[NSObject alloc] init];

//指针变量obj0保存新创建的NSObject对象A的内存地址，即obj0指针变量指向NSObject对象A，

//实际上，这里说也创建了obj0对象。

NSObject *obj1= ojb0;

//这里我们把指针变量obj0的值（也就是对象的内存地址）赋值给指针变量obj1，这时obj1也是指针NSObject对象A
```

你是不是觉得上面“创建了obj0对象”这一说法不严谨，而且有点奇怪，明明是创建了指针变量来指向对象A。虽然苹果的Foundation框架木有开源，我们具体不知道alloc和init具体的实现方式，但是有一点我们是可以知道的。

NSObject在发送alloc和init消息时，不仅仅开辟了内存区域并返回了对象指针，而且里面还保存了一个“retained”的变量，用于保存引用计数，同时其值初始化为1（表示此时的指针变量是创建对象的发起人，因此拥有该对象的ownership）。

这个“retained”变量用于保存获取对象拥有权的指针变量的个数，在MRC中，你需要retain来获取对象的拥有权，使用release来释放对象的拥有权。

创建对象，本质上指的是编译器开辟了内存区域，返回其对象指针，并把引用计数的值初始化为1。

因此上面的代码，指针变量obj0拥有对象A的ownership，而指针变量obj1因为没有retain而没有对象A的ownership。这样的话，当指针变量obj0指向的对象A释放后，指针变量obj1就会因为指向一个被释放的对象而成为dangering pointer。很明显，这种内存设计有点不合理，obj1指针变量保存了对象A的内存空间（也就是指向对象A），那么它应该也拥有了对象A的ownership。

而在ARC下，指针变量的指向和内存控制便更符合逻辑了。对象只要有_strong标识符（默认）的指针变量指向，它的内存空间就会一直在，而如果没有指针变量指向了，编译器侦查到便会把对象释放。



## 变量保存在哪里？

从上面，我们知道，变量就是一内存区域。那么，变量保存在哪里？

实际上，编译器对每个.m文件转换为机器代码后，会生成一个.o的目标文件（也称为可重定位的目标文件），目标文件可以其他目标文件合并并生成一个可执行文件。

我们可通过ELF文件来看看变量究竟保存在哪里。


对于Static类型的变量（静态变量、静态全局变量）和全局变量，其保存在.data和.bss，并在符号表中创建对应的符号。

对于局部变量，保存在栈上。（注意：.symtab的符号表不包含本地非静态变量的符号，也就是说，对应局部变量，变量对应的标识符号是在栈中被管理的）

对应对象变量，保存在heap上。


## 标识符的组合写法


在OC中，变量与指针标识符*和块标识符^结合时，写法也需要注意，先来看看一个简单的例子

```python
int *f();    //指针函数，这个函数返回的是int*类型的，也就是说，它返回一个指向int类型的指针变量
int (*f)();  //函数指针，这是指针变量f指向一个返回值是int的函数
```

我们知道，[]和()的优先级都是大于*和^的。我们经常也可以看到

```python
int (^f)()  //块指针，表示块指针变量指向一个返回值是int的块
int ^f()    //这是什么东东。。块函数？块是实际上是闭包，因此它一定是指向函数的。
另外，我们知道函数的返回值可以使指针，因此:
int (*f()(int)){...}  //返回函数指针，函数返回的是指向参数为int类型，返回值为int类型的函数指针。。
int (^f()(int)){...} //返回块指针，函数返回的是指向参数为int类型，返回值为int类型的块指针。。
```

实际上，使用typedef能简洁化

```python
typedef int (*func_t) (int);
typedef int (^blk_t) (int);
func_t f();
blk_t f();
```
